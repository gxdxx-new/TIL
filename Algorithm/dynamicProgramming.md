# **다이나믹 프로그래밍 (동적 계획법)**

---

## **다이나믹 프로그래밍이란**

- 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.
- 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시킨다.
- 다이나믹 프로그래밍과 분할 정복의 차이점
  1. 다이나믹 프로그래밍은 한 번 해결했던 문제를 다시 사용한다.
     - 이미 해결된 부분 문제에 대한 답을 저장해 놓는다.
     - 그 문제는 다시 해결할 필요가 없으므로 저장한 값을 반환한다.
  2. 다이나믹 프로그래밍은 문제들이 서로 영향을 미친다.

---

## **다이나믹 프로그래밍 조건**

- 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해본다.

1. **큰 문제를 작은 문제로 나눌 수 있다.**
2. **작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.**

---

## **탑다운 (Top-Down) VS 보텀업 (Bottom-Up)**

### **다이나믹 프로그래밍의 2가지 방식**

- 탑다운
  - 재귀 함수를 이용한다.
  - 큰 문제를 해결하기 위해 작은 문제를 호출한다.
  - 메모이제이션 기법을 사용한다.
- 보텀업
  - 반복문을 이용한다.
  - 작은 문제부터 차근차근 답을 도출한다.
  - 'DP 테이블'이라는 결과 저장용 리스트를 사용한다.
  - 다이나믹 프로그래밍의 전형적인 형태이다.

---

## **메모이제이션 (Memoization)**

- 탑다운 방식을 구현하는 방법 중 하나이다.
- 값을 저장하는 방법이므로 캐싱(Cashing)이라고도 한다.

1. **한 번 구한 결과를 메모리 공간에 메모해둔다.**
2. **같은 식을 다시 호출하면 메모한 결과를 그대로 가져온다.**

---

## **기본적인 피보나치 수열**

### **점화식**

- 인접한 항들 사이의 관계식을 의미한다.
- 수열의 항이 이어지는 형태를 간결하게 표현한다.
- **현재의 항을 이전의 항에 대한 식으로 표현할 수 있다.**

### **피보나치 수열의 점화식**

- <img width="300" alt="2_1" src="https://user-images.githubusercontent.com/35963403/135199151-3ed9c441-a6b7-4eae-b4ad-da774641c893.PNG">

  - n번째 피보나치 수 = (n - 1)번째 피보나치 수 + (n - 2)번째 피보나치 수
  - 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1

```python
# 피보나치 함수(Fibonacci Function)를 재귀 함수로 표현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(6))
```

<img width="400" alt="2_1" src="https://user-images.githubusercontent.com/35963403/135202311-1df9009b-047c-4f40-9b95-8a7e5458b2fd.PNG">

- 문제점
  - n이 커지면 수행 시간이 기하급수적으로 늘어난다.
  - 동일한 함수가 반복적으로 호출된다.

---

## **탑다운 (Top-Down) 방식을 사용한 피보나치 수열**

```python
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(X - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```

<img width="400" alt="2_1" src="https://user-images.githubusercontent.com/35963403/135205027-8b265fbd-95ac-4496-bedd-78bd9351d278.PNG">

- 시간 복잡도는 O(N)이다.
- 실선으로 처리된 노드는 계산하지 않고 리스트에서 값을 가져오거나 바로 1을 반환한다.
- 재귀 함수를 사용했기 때문에 오버헤드가 발생할 수 있다.

---

## **보텀업 (Bottom-Up) 방식을 사용한 피보나치 수열**

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수(Fibonacci Function)를 반복문으로 구현
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

- 반복문을 이용해서 오버헤드를 줄일 수 있다.
