# 리눅스

intel과 amd에서 나오는 CPU에서 동작하도록 나온 유닉스이다.

---

### 유닉스의 설계 철학

- 단순성
- 이식성
- 개방성

---

### 유닉스의 특징

- 다중 사용자, 다중 프로세스
- 쉘 프로그래밍 지원
  - 명령어나 유틸리티 등을 사용하여 작성한 프로그램
- 훌륭한 네트워킹 지원
  - ftp, telnet, WWW 등

---

### 유닉스 운영체제 구조

- 운영체제
  - 컴퓨터의 하드웨어 자원을 운영 관리한다.
  - 프로그램을 실행할 수 있는 환경을 제공한다.
- **커널(kernel)**
  - 운영체제의 핵심으로 하드웨어 운영 및 관리를 한다.
    - 프로세스, 메모리, 파일, 주변장치, 통신 등
- **시스템 호출(system call)**
  - 커널이 제공하는 서비스에 대한 프로그래밍 인터페이스 역할을 한다.
- **쉘(shell)**

  - 사용자와 운영체제(커널) 사이의 인터페이스 역할을 한다.
  - 사용자로부터 명령어를 입력 받아 해석하여 수행해주는 명령어 해석기이다.
  - 배시쉘(Bash Shell)

  <br/>

  <img width="300" alt="1_1" src="https://user-images.githubusercontent.com/35963403/132097543-a0a25403-a796-4aa6-9041-f826fd5f3233.PNG">

---

### 커널의 역할

- 프로세스 관리(Process Management)
  - 여러 프로그램이 실행될 수 있는 환경을 제공한다.
  - CPU 스케줄링을 통해 여러 프로세스들이 동시에 수행되도록 한다.
- 메모리 관리(Memory Management)
  - 메인 메모리가 효과적으로 사용될 수 있도록 관리한다.
  - 가상 메모리 관리 및 메모리 교체 정책을 실행한다.
- 파일 관리(File Management)
  - 저장장치(HDD, SSD)에 파일 시스템을 구성하여 파일을 관리한다.
- 주변장치 관리(Device Management)
  - 모니터, 키보드, 마우스와 같은 장치를 사용할 수 있도록 관리한다.
- 통신 관리(Communication Management)
  - 네트워크를 통해 정보를 주고받을 수 있도록 관리한다.

---

### 리눅스 장점

- 풍부하고 다양한 하드웨어를 효과적으로 지원한다.
- 저렴한 성능 요구 사양 및 안정성
- 인터넷에 맞는 강력한 네트워크 구축
- 다양한 응용 프로그램이 개발돼있다.
- 다양한 배포판이 있다.
  - 레드햇, 우분투, 페도라, CentOS 등
- 안드로이드: 리눅스를 기반으로 한다.

---

### 원격 로그인

텔넷

- 보안상의 이유로 사용되지 않는다.
- 주고받는 패킷에 담긴 데이터들이 암호화 되어 있지 않아서 노출이 된다.

PuTTY

- ssh(secure shell)을 이용해서 원격 로그인한다.
- 패킷이 암호화 되어서 노출 위험이 없다.

---

### 시스템 관리자

슈퍼유저

- 시스템을 관리할 수 있는 사용자이다.
- root 계정을 사용한다.

슈퍼유저 로그인

- 직접 root 계정으로 로그인
  - 보안상 취약
- 다른 계정으로 로그인 후
  ```javascript
  $ su [사용자명]     // substitute user
  ```
  - 사용자 명을 주지 않으면 root로 로그인된다.

---

### 사용자 계정 추가

사용자 추가/삭제

```javscript
# useradd [옵션] 사용자명
# userdel [-r] 사용자명     // -r: 사용자 홈디렉토리 파일 삭제
# passwd  사용자명
```

---

### 그룹 추가

- 유닉스/리눅스에서 사용자는 하나 이상의 그룹에 속한다.
- 그룹 추가/삭제
  ```javascript
  # groupadd [-g gid] 그룹명
  # groupdel 그룹명
  ```

<br/>

# 리눅스 사용

### 기본 명령어

날짜 및 시간 확인

```javascript
$ date
```

호스트 이름 확인 (시스템 관리자가 부여한 이름)

```javascript
$ hostname
```

운영체제 확인 (설치된 운영체제 이름)

```javascript
$ uname
```

로그인 한 사용자 확인 (다중)

```javascript
$ who
```

로그인 한 사용자 확인

```javascript
$ whoami
```

현재 디렉토리 내부의 파일 목록 확인

```javascript
$ ls
```

화면을 정리하고 첫째줄에 프롬프트 표시

```javascript
$ clear
```

암호 변경

```javascript
$ passwd
```

온라인 매뉴얼

- 뒤에 명령어를 입력하면 명령어에 대한 설명을 알려준다.

```javascript
$ man
```

명령어에 대한 간단한 설명

```javascript
$ whatis
```

all 옵션

```javascript
-a;
```

---

### 파일의 종류

- 일반 파일(ordinary file)
  - **데이터를 가지고 있다.**
  - 디스크에 저장된다.
- 디렉토리 파일(directory file)
  - **자신이 가지고 있는 내부 디렉토리 또는 파일을 가지고 있다.**
  - 폴더(folder)와 같다.
  - 디렉토리(폴더) 자체도 하나의 파일이다.
  - 한 디렉토리는 다른 디렉토리를 포함함으로써 계층 구조를 이룬다.
- 특수 파일(special file)
  - 물리적인 장치(device)에 대한 내부적인 표현이다.
  - 키보드(stdin), 모니터(stdout), 프린터 등도 파일처럼 사용한다.
    - ex) 프린터 출력 -> 프린터 파일에 대한 쓰기 연산 수행

---

### 디렉토리 계층구조

- 리눅스 디렉토리

  - 루트로부터 시작한다.
  - Tree 형태의 계층구조를 이룬다.
  - 루트가 한개만 있다.

  <img width="500" alt="2_1" src="https://user-images.githubusercontent.com/35963403/134766060-3ed19a6b-8bb1-42ac-a8d2-0986d486bab5.PNG">

---

### 홈 디렉토리/현재 작업 디렉토리

- 홈 디렉토리(home directory)
  - 각 사용자마다 별도의 홈 디렉토리가 있다.
  - 사용자가 로그인하면 홈 디렉토리에서 작업을 시작한다.
- 현재 작업 디렉토리(current working directory)
  - 현재 작업 중인 디렉토리이다.

---

### 경로명

- 파일이나 디렉토리에 대한 **정확한 이름**
- 절대 경로명 (absoulte path name)
  - **루트 디렉토리로부터 시작**하여 경로 이름을 정확하게 적는 것이다.
- 상대 경로명 (relative path name)
  - **현재 작업 디렉토리로부터 시작**해서 경로 이름을 적는 것이다.

---

### 파일명 개수

```javascript
$ 명령어 파일명
$ 명령어 파일명*      // 0개 혹은 그 이상
$ 명령어 파일명+      // 1개 혹은 그 이상
```

---

### 디렉토리 관련 명령

**pwd (print working directory)**

- 현재 작업 디렉토리의 **절대 경로명**을 출력한다.

```javascript
$ pwd
```

**cd (change directory)**

- 현재 작업 디렉토리를 지정된 디렉토리로 이동한다.
- 디렉토리를 지정하지 않으면 홈 디렉토리로 이동한다.
- **$ cd ~** : 홈 디렉토리로 이동한다.

```javascript
$ cd [디렉토리]
```

**which**

- 명령어의 절대 경로를 보여준다.

```javascript
$ which 명령어
```

**mkdir (make directory)**

- 새 디렉토리를 생성한다.
- -p: 중간 디렉토리 자동 생성 옵션
  - ex) ~/dest 디렉토리가 없는 경우

```javascript
$ mkdir ~/dest/dir1
mkdir: '/home/chang/dest/dir1' 디렉토리를 만들 수 없습니다: 그런 파일이나 디렉토리가 없습니다.

$ mkdir -p ~/dest/dir1  // 가능
```

```javascript
$ mkdir [-p] 디렉토리
```

**rmdir (remove directory)**

- 디렉토리를 삭제한다.
- **빈 디렉토리만 삭제할 수 있다.**

```javascript
$ rmdir 디렉토리
```

**ls (list)**

- 디렉토리의 내용을 리스트로 보여준다.

```javascript
$ ls
$ ls -a     //  -a(all): 숨김 파일 표기
$ ls -s     //  -s(size): 크기 표기
$ ls -l     //  -l(long): 자세한 정보(파일 속성) 표기
$ ls -F     //  파일 종류 표기(*: 실행파일, /: 디렉토리, @: 심볼릭 링크)
$ ls -R     //  -R(Recursive): 모든 하위 디렉토리 표기, 재귀적으로 실행된다.
$ ls -asl   //  -a, -s, -l을 결합
```

**cat (concatenate)**

- 파일(들)의 내용을 그대로 화면에 출력한다.
- 파일을 지정하지 않으면 표준입력 내용을 그대로 화면에 출력한다.
- -n을 입력하면 줄번호가 나타난다.

```javascript
$ cat [-n] 파일*
```

- 파일 읽기

```javascript
$ cat cs1.txt
```

- 파일 결합

```javascript
$ cat cs1.txt cs2.txt
```

- 파일 편집

```javascript
$ cat     //  키보드로부터 입력받아 그대로 출력
...
^D        //  (ctrl-D: 입력의 끝을 나타냄)
```

```javascript
$ cat > cs1.txt     //  키보드로부터 입력받은 내용을 파일로 저장 (파일 라인 단위 편집)
...
^D
```

```javascript
$ cat cs1.txt cs2.txt > cs3.txt     //  파일 결합하고 저장
```

**more**

- 파일(들)의 내용을 페이지 단위로 화면에 출력한다.

```javascript
$ more 파일+
```

**head**

- 파일(들)의 앞부분을 화면에 출력한다.
- 파일을 지정하지 않으면 표준입력 내용을 대상으로 한다.
- -n으로 보고싶은 라인 수를 지정할 수 있다.
  - 기본적으로 처음 10줄을 출력한다.

```javascript
$ head [-n] 파일*

ex) $ head -5 cs1.txt
```

**tail**

- 파일(들)의 뒷부분을 화면에 출력한다.
- 파일을 지정하지 않으면 표준입력 내용을 대상으로 한다.
- -n으로 보고싶은 라인 수를 지정할 수 있다.
  - 기본적으로 마지막 10줄을 출력한다.

```javascript
$ tail [-n] 파일*

ex) $ tail cs1.txt
```

**wc (word count)**

- 파일에 저장된 줄(l), 단어(w), 문자(c)의 개수를 세서 출력한다.
- 파일을 지정하지 않으면 표준입력 내용을 대상으로 한다.

```javascript
$ wc [-lwc] 파일*

ex)
$ wc cs1.txt
38 218 2088 cs1.txt
$ wc -l cs1.txt
38 -l cs1.txt
$ wc -w cs1.txt
218 -w cs1.txt
$ wc -c cs1.txt
2088 cs1.txt
```

**cp (copy)**

- 파일1의 복사본 파일2를 현재 디렉토리 내에 생성(복사)한다.
- 복사 대상 파일과 이름이 같은 파일이 이미 존재하면 덮어쓰기한다(overwrite).
  - -i (interactive) 대화형 옵션으로 덮어쓰기 전 확인할 수 있다.

```javascript
$ cp [-i] 파일1 파일2

ex) $ cp cs1.txt cs2.txt
```

- 파일(들)의 복사본을 디렉토리 내에 생성한다.

```javascript
$ cp 파일(들) 디렉토리

ex) $ cp cs1.txt /tmp
```

- 디렉토리1을 디렉토리2로 복사한다.
- **디렉토리1의 하위 파일도 모두 복사된다.**

```javascript
$ cp -r 디렉토리1 디렉토리2
```

mv (move)

- 파일1의 이름을 파일2로 변경한다.
- rename의 개념이다.
- -i는 대화형 옵션이다.

```javascript
$ mv [-i] 파일1 파일2
```

- 파일을 디렉토리 내로 이동한다.

```javascript
$ mv cs3.txt /tmp
```

- 디렉토리1을 지정된 디렉토리2로 이름을 변경한다.
- 디렉토리도 파일이기 때문에 파일에 작업 가능한 명령어는 디렉토리에서도 가능하다.

```javascript
$ mv 디렉토리1 디렉토리2
```

rm (remove)

- 파일(들)을 삭제한다.
- -i는 대화형 옵션이다.

```javascript
$ rm [-i] 파일+
```

- 디렉토리를 전체 삭제한다.
- -r은 리커젼 옵션으로 디렉토리 아래의 모든 것을 삭제한다.
- -i는 대화형 옵션이다.

```javascript
$ rm [-ri] 디렉토리
```

- -i: 확인 후 삭제 (interactive)
- -f: 무조건 삭제 (force)
- -r: 디렉토리 삭제 (recursion)
